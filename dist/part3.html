<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" type="text/css" href="/style.e308ff8e.css">
		<link rel="stylesheet" type="text/css" href="/bootstrap.5f792716.css">
		<title>Computer Hardware Part 3</title>
	</head>
	<body>
		<div class="container">
            <h1>Part 3: Multiplication and Division</h1>
			<p>So we've figured out addition and subtraction. Multiplication, then, doesn't actually seem so bad; indeed, it is only repeated addition...</p>

			<h3>Multiplication</h3>
			<p>So now we turn to multiplication. Let's think about how we might multiply two numbers in base ten. The standard method is to do something like this:</p>
			<pre style="font-size: large">
	   471
	&times; 1011
	------
	   471
	  471
	 000
	471
	------
	  1     (carry from 4+7)
	475181
	------
	476181
			</pre>
			<p>You might have noticed that I deliberately chose to make the second number only have the digits 0 and 1. This is a very useful feature of binary: since the bits can only ever be 0 or 1, at each step, we either add the number as is or we don't. (In contrast, with base ten we might have to add some multiple of 471.)</p>
			<p>For now, we're also going to ignore overflow entirely, and just assume that we can somehow output twice as many bits. We'll also be using unsigned integers, so 1001 means 8+1 = 9, not -7. (Signed multiplication is a little trickier. However, if you don't care about overflow and want a 4-bit output, you can actually multiply the two's complement representations directly, as if they were positive numbers! Try it yourself if you want.) But for now, let's jump right to a naive attempt at building a circuit:</p>

			<div class="exploration" id="multiplier-naive">

			</div>

			<p>Actually, the top right adder isn't really necessary, although it could be helpful if you wanted to have a multiply-add operation that computes (A * B) + C given three inputs.</p>
			<p>But that gets a bit unwieldy if you try to imagine 32 or 64 of them. In fact, that would be <em>extremely</em> slow. Although it all looks instantaneous here, each of those wires is distance that electrons have to move at some finite speed.</p>
			<p>Even the "add" operation itself is fairly slow for a 32-bit machine; a signal has to travel through 32 full adders to make the final answer. (There are no shortcuts: imagine something like 7 + 3999994. You can't find out the millions digit until you finish adding the right six digits.) Multiplication would then require waiting for 32 of those add cycles.</p>
			<p>There are actually more complicated multiplier designs that cut down on this time considerably, by using something called a "carry save adder". These designs are quite complicated, but the basic idea is similar to how I did the multiplication: I wrote (well, typed) all the 471's, then added each column and carried as needed.</p>
			<p>But the reason this works is that multiplication is just repeated addition. All the information you need is right there in plain sight to begin with. Unfortunately, this is <em>not</em> true of division, which means we're going to need more complicated steps to make that work.</p>

			<!-- Introducing Division -->
			<h4>Division...</h4>
			<p>Is it just me, or does division feel harder than multiplication? Here's an example of some long division, side-by-side with the multiplication from before.</p>
			<div>
				<pre style="display: inline-block">
&nbsp;   <u>    1011</u>
471 | 476223
&nbsp;   &nbsp; 471
&nbsp;   &nbsp; ---
&nbsp;   &nbsp;  05223
&nbsp;   &nbsp;  000
&nbsp;   &nbsp;  -----
&nbsp;   &nbsp;   5223
&nbsp;   &nbsp;   471
&nbsp;   &nbsp;   ----
&nbsp;   &nbsp;    513
&nbsp;   &nbsp;    471
&nbsp;   &nbsp;    ---
&nbsp;   &nbsp;     42
				</pre>
				<pre style="display: inline-block">
   471
&times; 1011
------
   471
  471
 000
471
------
  1
475181
------
476181
				</pre>
			</div>


			<p>One thing you may have noticed is that division took more steps. There is no column-by-column trick to make the subtraction faster. What's worse, we have to make a <em>decision</em> at each step, of whether or not to subtract 471 (actually, in base ten there are ten possible subtractions including zero). There's no good way to predict, say, whether the last step will need a subtraction or not without calculating it all the way down to 513.</p>
			<p>This is going to involve a much different kind of circuit from the static ones we've seen so far. Our circuit is going to need a lot more time, and a bunch of new components. Since this is going to be a lot of content, I've decided to <strong>first build a slow multiplier</strong> that will feature a lot of the components we need to build a divider. But before we get to any of that, let's start with three new components...</p>

			<!-- Choice Gates -->
			<h3>Making Decisions</h3>
			<p>Remember how I said that with division, we need to be able to choose between two different options? How would you go about doing that?</p>
			<p>I mean, a bit is already in some sense a "choice" between ON or OFF. But what if you need to choose between, say, two 32-bit numbers? Or what about more than two, even?</p>
			<p>Actually, for the purposes of multiplication and division, we will only need to choose between two options, so let's figure that out. The simplest case, of course, is choosing between two bits. This isn't very complicated, but there are some subtleties to understand.</p>
			<p>The gate we're going to build is called a "multi<b>plex</b>or" (<em>not</em> a multi<u>pli</u>er!) or a "selector" (although I personally like the name "choice gate"). It takes three inputs: the selection input S, and two others which I'll call A and B. The output is determined as follows:</p>
			<ul>
				<li>If <strong>S</strong> is <strong class="bit-1">ON</strong>, then we output whatever <strong>A</strong> is.</li>
				<li>If <strong>S</strong> is <strong class="bit-0">OFF</strong>, then we output whatever <strong>B</strong> is.</li>
			</ul>
			<p>It's actually a little tricky to get this one right. I've started you off with a hint (namely, how I arranged the wires). It's your job to figure out which gates to use.</p>
			<div class="exploration" id="choice">
				<h4>Choice Exploration</h4>
			</div>

			<!-- Clocks -->
			<h3>Clocks and Counters</h3>
			<p>In computer hardware, one of the fundamental concepts is the <em>clock</em>. This is a signal that alternates up-down-up-down-up-down-... for as long as the computer has power. This is how it knows when, for instance, it is time to run the next instruction safely (any operations are required to take less time than one cycle of the clock, or else the program has to wait).</p>
			<p>Here, I'm representing this with the left output being the "up" phase and the right output being the "down" phase of the clock. It also has an input bit, which I use more as a "start button" in the multiplier and divider circuits to activate the clock (you could think of it as the power source).</p>
			<div class="exploration" id="clock">
				<h4>Clock Exploration</h4>
			</div>

			<p>It would be nice to

			</p><h3>Registers</h3>
			<p>In order to do that, we need some more persistent components, something that can "remember" what it had before. That looks difficult, but we can actually implement it fairly easily with a simple trick: we take the output and wire it back into the input!</p>
			<p>"Registers" are just a fancy name for a group of bits that stores information. A 32-bit register, for instance, can hold any 32 bits you want for as long as you need them (if the power stays on).</p>
			<p>The design I am going to use is non-informatively called a "D latch". There are two inputs: a "load" input and a "data" input. If the former is ON, the register adopts the value of the "data" input; if the "load" is OFF, the register remembers what it had before.</p>
			<p>This process might remind you of something. Indeed, we can simulate this by simply wiring a choice gate back on itself.</p>

			<div class="exploration" id="register">
				<h4>Register Exploration</h4>
			</div>
			<p>In practice, however, registers are usually implemented with more complicated circuitry that responds to the clock. This is because in real life, signals take time to move through wires. Allowing registers to change only when the clock ticks can prevent data from being corrupted. This is all getting very advanced, though, so we'll use the unclocked version of the register for now.</p>


			<!-- Slow Multiplication -->
			<h3>Multiplication, the Slow Way</h3>
			<p>With all of those components, it is time to do our multiplication!</p>
			<p>What we're going to do this time is to start with a blank "canvas" of bits. It's easier to keep the adder in one place and move bit values, so we add into the upper 6 bits (the final answer may be as large as 12 bits) and then shift the register downward. (By "shift", I mean to shift the <strong>values</strong> of the bits. So in a shift cycle, each bit inherits the value of its left neighbor.) In decimal, it looks like this:</p>
			<pre id="slow-mult-pre">
	Register:  000000    [1011]
	Add:       471000    [101<strong>1</strong>]
	Shift:     047100    [ 101]
	Add:       518100    [ 10<strong>1</strong>]
	Shift:     051810    [  10]
	Don't add: 051810    [  1<span class="zero">0</span>] (don't add because of the 0)
	Shift:     005181    [   1]
	Add:       476181    [   <strong>1</strong>]
	</pre>
			<p>To implement this in hardware, we need to keep track of which bit in the second number we are on. The easiest way to do this is with a second register of size 6. It gets shifted when the large one does, and we just tell the adder to keep the original value of the register if that bit is 0. (Notice the "Don't add" step above because the hundreds digit was a zero.)</p>





			<p>So, at last, we come to the multiplier hardware. There's a lot going on here, but don't panic! A detailed explanation follows, but see if you can figure out what's going on by watching it. Remember, this isn't what multiplication usually looks like; it's just here to compare with division.</p>
			<h4 class="text-success">Exploration Instructions</h4>
			<p><strong>Heads up!</strong> Unlike the previous simulations that calculated immediately, multiplication and division take time. To operate this version:</p>
			<ol start="0">
				<li><strong class="text-danger">Dark Red = 0</strong> and <strong class="text-success">Light Green = 1</strong>.</li>
				<li>Click the circles in the <strong>upper left</strong> to make the first number. <em>(You have to make the number in binary. The display number can NOT be typed into.)</em></li>
				<li>Click on the row of circles in the <strong>upper mid-right</strong> to make the second number.</li>
				<li>When you are ready, click the <strong>large red button</strong> in the upper right corner to turn the machine "on". (Note that the "Play" button enables animation but won't actually start the calculation unless the big red bit is made green.)</li>
				<li>Too fast? There is speed control to the right of (or below) the exploration. Click "pause" to pause the circuit and "step" to do one iteration at a time. You can also adjust the animation speed.</li>
			</ol>
			<p>For best results, try setting the second input to something with several 1 bits and several 0 bits. A good number for this is 110011 (51).</p>
			<div class="exploration" id="multiplier-full"></div>

			<h3 id="mult-what-happened">Multiplication: What Just Happened?</h3>
			<p>All right, so maybe all that wiring confused you a little. Let's go through it piece by piece. You probably noticed there were two alternating actions, which I will call "add" and "shift". "Shift" moves a bunch of values and "add" helps the product grow. In more detail:</p>
			<div class="clearfix">
				<img src="/mult_b.b919f53d.png" alt="Closeup of the upper right" class="float-start img-thumbnail me-2" width="300">
				<p>This portion of the circuit, surrounding the second input, copies that input into a register. The wires coming from the upper right come from a NOT gate on the start button. If the start button is off, that not gate is on, so the selectors will choose the input bits, effectively <b>resetting this register</b>. Otherwise, they will select the value of the <b>previous bit, thus trying to shift the register</b>.</p>
				<p>However, the "write" signal is connected to an OR gate. The "write" is active when the teal wires are on OR the start button is off. Teal is the "shift" signal, and the start button being off is a reset. So <b>in shift phase, the values all move one place right</b>, but <b>in add phase, this register stays put</b>. The value of the LSB (least significant bit) doesn't go anywhere in shift phase, but it does have another purpose...</p>
			</div>
			<div class="clearfix">
				<img src="/mult_adder.9cd7c507.png" alt="Closeup of the Adder" class="float-start img-thumbnail me-2" width="300">
				<p>...and for that, we come to the adder. Its purpose is to <b>add the first input</b> to the upper 6 bits of the product register. The selector decides whether to use this sum (if the LSB from above is 1) or keep the state as is (if 0). The faded purple wire is connected to the product register, while the solid purple wire comes down to more selectors.</p>
			</div>
			<div class="clearfix">
				<img src="/mult_prodReg.2efe3b26.png" alt="Closeup of the Adder" class="float-start img-thumbnail me-2" width="300">
				<p>Those selectors then control what happens to the product register. Because there are only two phases, I decided not to make these formal "register" bits, but in practice you can still think of it as a register. The faded teal wires are the control signal for shifting (just like above). When those are active, all the bit values slide one place to the right. Otherwise, the bits on the right hold their own state, while those on the left receive the value from the selector above (which might or might not be the addition result).</p>
			</div>

			<p>Of course, now we just made a value that has twice as many bits as the computer. If your computer is 64-bit, then the multiplication can theoretically use as many as 128 bits. (Challenge: Find a multiplication in the above where the 12th bit from the right is a 1.) One approach, used by the MIPS architecture, is to store the result in a special "high" and "low" register. Then, programs can use an instruction called <code>mfhi</code> and <code>mflo</code> ("move from high/low") to extract the two halves separately. Usually only the lower half is actually used; the upper half would only check if there is overflow.</p>

			<h3>Division</h3>
			<p>Long division is also rather tricky. Let's take the example from earlier with a slight modification:</p>
			<pre>
&nbsp;   <u>    1011</u>
471 | 476223
&nbsp;   &nbsp; 471
&nbsp;   &nbsp; ---
&nbsp;   &nbsp;  05223
&nbsp;   &nbsp;  000
&nbsp;   &nbsp;  -----
&nbsp;   &nbsp;   5223
&nbsp;   &nbsp;   471
&nbsp;   &nbsp;   ----
&nbsp;   &nbsp;    513
&nbsp;   &nbsp;    471
&nbsp;   &nbsp;    ---
&nbsp;   &nbsp;     42
			</pre>
			<p>Many things are similar to multiplication, actually. If you remember the multiplication hardware, we started with an empty register, and added to the left half and then shifted all the bits to the right. Here, we do the opposite: the register now starts with the numerator, and we repeatedly subtract and shift <em>left</em>.</p>
			<p>When the subtractor gets its result, we first check the carry-out bit and see if it is 0. (If it were 1, then we got a negative result.) This is sent into choice gates to decide whether or not to use the subtraction.</p>
			<p>Now, a naive implementation of the hardware would just have a second register for storing the quotient. However, because of the way we shift the register upward, we can actually just use the lower half of the register to hold the quotient.</p>
			<p>Why is this? Well, when done this way, we can now use the same hardware for multiplication and division! The <code>mfhi</code> instruction would now mean "extract the remainder", and <code>mflo</code> now gets the quotient. </p>
			<p>Like before, I made the power button shut itself off when the computation is done. Notice how it immediately resets the big row now. The top number is the numerator and the bottom number is the denominator.</p>
			<div class="exploration" id="divider-full"></div>
			<p>Here's a few things to try:</p>
			<ul>
				<li>Try some stress tests: 63 divided by 1, 63 divided by 63, 1 divided by 63, 1 divided by 1, 0 divided by 1 or 63.</li>
				<li>What happens if you divide by zero? See if you can guess, then try it. (A real computer would issue some kind of error if you tried to do so, but that requires more work.)</li>
			</ul>
		</div>
	</body>

	<script src="/main.c39d6dcf.js"></script>
</html>
