<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="style.fe8bb943.css"><link rel="stylesheet" type="text/css" href="bootstrap.8e1af471.css" <="" head=""></head><body> <div class="container"> <h1>Arithmetic in Computer Hardware</h1> <h4><a href="advanced.html">Skip right to Part 3</a> <small>(part 2 is not made yet)</small></h4> <h3>The Basics</h3> <p>You're probably aware that computers store numbers as a series of 0's and 1's. These 0s and 1s are sent around in various complicated circuits to do calculations.</p> <p>But how does the computer actually do arithmetic? Before we can get into that, we need to learn how the computer actually stores numbers in the first place. There are a few different methods, but we'll focus on whole numbers for now.</p> <p>Humans generally use base ten notation, which means that a number like 314 means three hundreds, one ten, and four units. Computer wiring generally uses base two, or binary, where the only digits are 0 and 1. For example, 110 means not "one hundred and ten" but "one four and one two", or six. Instead of powers of ten, binary digits use powers of two.</p> <p>I promised this would be interactive. Here's a simple exploration to show how binary numbers work. I've included six binary digits, or bits, which means the maximum number you can reach is 2<sup>6</sup>&nbsp;-&nbsp;1, or 63. (With six decimal digits you could reach 10<sup>6</sup>&nbsp;-&nbsp;1 = 999,999.)</p> <h4>Exploration Instructions</h4> <ul style="font-size:large"> <li><strong class="bit-0">Dark Red</strong> indicates a <strong class="bit-0">zero/off</strong> bit.</li> <li><strong class="bit-1">Green</strong> indicates a <strong class="bit-1">one/on</strong> bit. (In the explorations the green is lighter.)</li> <li>Clicking on <strong>circular</strong> ("input") bits switches them.</li> <li>Other components <em>cannot</em> be interacted with directly.</li> </ul> <p>This one just shows you the value of a 6-bit number. You can click on the bits to change them.</p> <div class="exploration" id="binary-basic"></div> <h3>Simple Operations</h3> <p>Now, in order to do anything useful with these numbers, we need to have ways do to computations on bits. As is common in computer design, we start with the most basic possible components, and work our way up.</p> <p>What are the simplest possible operations? Well, taking the opposite of a bit (change 0 to 1 and vice versa) is useful. That's called a "NOT gate", because it takes in a value and outputs whatever that value is <em>not</em>.</p> <p>But to do real computations, we need bits to interact with each other. The next simplest kind of operation involves <em>two</em> inputs. There are many possibilities, but the simplest ones that come to mind are the following:</p> <ul> <li>AND: Gives a 1 if both of the inputs are 1's. Otherwise it gives 0.</li> <li>OR: Gives a 1 if either, or both, inputs are 1's. If both are zero, it outputs 0.</li> </ul> <p>The English word "or" is annoyingly ambiguous; sometimes it allows both ("you must be 48 inches tall or accompanied by an adult"; they wouldn't turn away two tall adults who want to ride together!) and other times it does not ("it comes with salad or fries" probably means you pick one). Computer scientists cannot tolerate this kind of ambiguity, and so they have decided to call the "one or both" option "OR". When you want "one or the other, but <em>not</em> both", they call it "exclusive or", also known as "XOR".</p> <p>Why am I saying this? Well, first, I want to make it clear what an "OR" gate does when you see it in a circuit. Second, the XOR gate, though more complicated, is surprisingly useful later on...</p> <table class="table"> <thead> <tr> <th>First Input</th> <th>Second Input</th> <th>AND</th> <th>OR</th> <th>XOR</th> </tr> </thead> <tbody> <tr> <th>0</th> <th>0</th> <td>0</td> <td>0</td> <td>0</td> </tr> <tr> <th>0</th> <th>1</th> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <th>1</th> <th>0</th> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <th>1</th> <th>1</th> <td>1</td> <td>1</td> <td>0</td> </tr> </tbody> </table> <p>The above is a "truth table" for three of the four main operations. (The fourth, NOT, only has one input.)</p> <p>Now, I will not go into how one actually builds a NOT gate or an AND gate. That's getting a bit too far into electrical engineering. Instead, we'll treat those as "atoms", basic components from which everything else will be built.</p> <p>Instead, here is another exploration. There are no numbers this time. The squares are the outputs; you can't change them directly. In case you skipped the instructions above: Green is 1, red is 0. Click on circles to switch them. Squares are the output. The shapes I've used are common in electrical engineering, but I've also added the symbols <strong>&</strong>, <strong>O</strong>, and <strong>X</strong> to make it more clear. (If you're still confused as to which gate is which&mdash;and I admit to being a little unclear on that&mdash;the best way to learn is to <em>try it yourself</em>!)</p> <div class="exploration" id="gates"></div> <h3>Addition</h3> <p>With these four gates, we can make almost anything. But let's not get too far ahead of ourselves. It's still not immediately obvious how you would add two numbers using only those gates.</p> <p>So for now let's consider the simplest possible case: adding two individual bits. (In other words, we're adding two numbers that can be either 0 or 1.) Now, the result could be either 0, 1, or 2, which is three possiblilities, so we'll need more than one bit. For these purposes, we'll have two output bits, one that means "1" and one that means "2".</p> <p>Here's what we're going for. I've made a little black box (or should I say, grey trapezoid) machine that does the addition. Play around with it and see if you can tell what it is doing...</p> <div class="exploration" id="half-adder-cheat"></div> <p>Here's the gates exploration again. See if you can find a similarity between the adder and some of the gates. (Hint: The "1" and "2" use different gates; there's no real connection between them. Note that we are allowed to cross wires over each other.)</p> <div class="exploration" id="gates-again"></div> <p>Did you figure it out? If you did, good job! If not, let's see how we can discover it from scratch. (It might help to read this section even if you think you got it; the "1" output is a little tricky.)</p> <p>With these kinds of problems, it helps to write down <em>exactly</em> what we want the wiring to do. We have two inputs, A and B.</p> <ul> <li>If both A and B are <strong class="bit-0">OFF</strong>, then both 1 and 2 are off.</li> <li>If only one of the two (A or B) is <strong class="bit-1">ON</strong>, then "1" should be <strong class="bit-1">ON</strong> but "2" should be off.</li> <li>If both A and B are <strong class="bit-1">ON</strong>, then "1" should turn off but "2" should turn <strong class="bit-1">ON</strong>.</li> </ul> <p>It should be fairly obvious by now that "2" needs to be an AND gate. I hope you've also spotted that "1" should be an XOR gate, but if you guessed inclusive OR, it's okay -- mistakes are part of learning! (That also shows the value of writing everything out. It's much harder to forget about the double-1 case if you have to write it out. In fact, we probably should have made a truth table.)</p>  <p></p> <h3>That was only half the work</h3> <p>What we just conceptualized was called a "half adder". Why half? Because if you're trying to add two numbers, sooner or later you have to worry about carrying. The "2" output from above  would be our carry; it's a little like the tens digit in an addition like this:</p> <pre>addition:
 (1)
  58
+ 66
----
   4
 124</pre> <p>The lonely "4" above the answer represents the fact that you normally write the 4 first, <em>then</em> carry the 1, and add 1 + 5 + 6 = 12.</p> <p>So how can we handle carries? This is a bit complicated, so we'll definitely need a truth table. See if you can do it yourself!</p> <p>We'll technically have three inputs here, but one of them is the "carry" bit that represents the "2" output of the previous column. Also, there could be three ON (1) inputs. Instead of making a third output, we can just say that if all three are on, we'll turn the "1" <em>and</em> "2" inputs on. (Just like binary! 1 + 2 = 3.)</p> <table class="table" id="fill-in"> <thead> <tr> <th>Input A</th> <th>Input B</th> <th>Carry In</th> <th>Output 1</th> <th>Output 2</th> </tr> </thead> <tbody> <tr> <th>0</th><th>0</th><th>0</th> </tr> <tr> <th>1</th><th>0</th><th>0</th> </tr> <tr> <th>0</th><th>1</th><th>0</th> </tr> <tr> <th>1</th><th>1</th><th>0</th> </tr> <tr> <th>0</th><th>0</th><th>1</th> </tr> <tr> <th>1</th><th>0</th><th>1</th> </tr> <tr> <th>0</th><th>1</th><th>1</th> </tr> <tr> <th>1</th><th>1</th><th>1</th> </tr> </tbody> </table> <p>Did you get it? Scroll down for the answer. The right column has value 2 but I wrote 0s and 1s because that is more standard (there's no second voltage level or anything like that).</p> <table class="table"> <thead> <tr> <th>Input A</th> <th>Input B</th> <th>Carry In</th> <th>Output 1</th> <th>Output 2</th> </tr> </thead> <tbody> <tr> <th>0</th><th>0</th><th>0</th> <td>0</td> <td>0</td> </tr> <tr> <th>1</th><th>0</th><th>0</th> <td class="table-success">1</td> <td>0</td> </tr> <tr> <th>0</th><th>1</th><th>0</th> <td class="table-success">1</td> <td>0</td> </tr> <tr> <th>1</th><th>1</th><th>0</th> <td>0</td> <td class="table-success">1</td> </tr> <tr> <th>0</th><th>0</th><th>1</th> <td class="table-success">1</td> <td>0</td> </tr> <tr> <th>1</th><th>0</th><th>1</th> <td>0</td> <td class="table-success">1</td> </tr> <tr> <th>0</th><th>1</th><th>1</th> <td>0</td> <td class="table-success">1</td> </tr> <tr> <th>1</th><th>1</th><th>1</th> <td class="table-success">1</td> <td class="table-success">1</td> </tr> </tbody> </table>  <p>But how do we wire this? If you think about it, to adjust the "1" output for carries, all we have to do is <em>add</em> the carry to the original "1" (from A&nbsp;+&nbsp;B). Now, the "2" is a bit trickier. Looking at the truth table, we see there are four possibilities: A+B, A+C, B+C, and A+B+C (which is three, but 3 = 1 + 2).</p> <p>We could make three AND gates (A and B, B and C, A and C) and OR them all together. However, we already have one of those (A AND B) from the half adder, and we also have "A XOR B", which means "one of A,B is on". So we can take that wire AND C to handle both the AC and BC cases.</p> <p>At this point, the circuit has gotten a bit complicated. With five gates, I've taken the liberty to add small red/green displays on three of them (the other two control the actual outputs). You can see that turning on one of the three inputs ("C" is also an input!) activates only the "1", and so on, but it happens in several different ways.</p> <div class="exploration" id="full-adder1"></div>  <h3>Putting it all together</h3> <p>So once we have a full adder, all we need to do for multiple bits is to chain a whole bunch of them together!</p> <p>On the left side, I've put a basic implementation of the hardware showing the individual gates that make a basic four-bit adder. On the right, I've abstracted that away to a single component that does the same thing.</p> <p>Click on red and green <strong>circles</strong> to change the input bits. Red = 0, green = 1. The square bits are the outputs. The numbers show what your inputs and outputs are in decimal, but you <strong>cannot</strong> type numbers in. I did that on purpose. Click on the bits directly!</p> <div class="exploration" id="adder"></div>  <h3>Making Decisions</h3> <p>Another important component we will need is a <b>selector</b>. Essentially, a choice gate allows the circuit to choose between two options based on the value of a third. (If you've done any programming, you might know this as the <code>condition ? thing1 : thing2</code> operator, or <code>thing1 <strong>if</strong> condition <strong>else</strong> thing2</code> in Python.)</p> <p>For our purposes, we will make selectors one bit at a time. Call the inputs A, B, and C. The logic is this:</p> <ul> <li>If A is on (1), then we ignore C and output B.</li> <li>If A is off (0), then we ignore B and output B.</li> </ul> <p>To do this "if-else" in terms of logic gates, we know that we only want B to be used when A is on, so that would be an AND gate: (A and B). For C, we want that to be used whenever A is off, so that looks like ((not A) and C). Finally, since either of those two options is allowed, we use an OR gate to connect them: (A and B) or ((not A) and C).</p> <p>As usual, the circuit implementation is on the left and the abstracted component is on the right. Click on red and green circles to switch them on and off.</p> <div class="exploration" id="choice"></div>  <h3>Next Steps</h3> <p>Well, this whole thing is still under construction. There's going to be a part 2 where we talk about subtraction and two's complement. But I <strong>do</strong> have a <a href="advanced.html">part 3</a> about multipliers and dividers. That might be exactly what you came here for.</p> </div> <footer> Copyright &copy; 2021 Croix Gyurek. All rights reserved. </footer> </body><script src="main.77eb61d2.js"></script></html>